// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * SapoCore: shared owner/pause/reentrancy/timelock helpers + SafeERC20.
 * Inherited by product contracts to reduce duplication in source and standardize behavior.
 * NOTE: This is inheritance (not delegatecall) to keep it straightforward and safe.
 */
abstract contract SapoCore {
    // ─────────────────────────────────────────────────────────────────────────────
    // Custom Errors
    error ErrAuth();
    error ErrPaused();
    error ErrZero();
    error ErrExists();
    error ErrNoOp();
    error ErrActive();
    error ErrRole();
    error ErrOverflow();

    // ─────────────────────────────────────────────────────────────────────────────
    // Owner + Pause
    address public owner;
    address public pendingOwner;
    bool    public paused;

    event OwnershipTransferStarted(address indexed from, address indexed to);
    event OwnershipTransferred(address indexed from, address indexed to);
    event Paused(address indexed by);
    event Unpaused(address indexed by);

    modifier onlyOwner() {
        if (msg.sender != owner) revert ErrAuth();
        _;
    }
    modifier whenNotPaused() {
        if (paused) revert ErrPaused();
        _;
    }

    constructor(address _owner) {
        if (_owner == address(0)) revert ErrZero();
        owner = _owner;
    }

    function transferOwnership(address to) external onlyOwner {
        if (to == address(0)) revert ErrZero();
        pendingOwner = to;
        emit OwnershipTransferStarted(owner, to);
    }
    function acceptOwnership() external {
        if (msg.sender != pendingOwner) revert ErrAuth();
        address old = owner;
        owner = pendingOwner;
        pendingOwner = address(0);
        emit OwnershipTransferred(old, owner);
    }
    function pause()   external onlyOwner { paused = true;  emit Paused(msg.sender); }
    function unpause() external onlyOwner { paused = false; emit Unpaused(msg.sender); }

    // ─────────────────────────────────────────────────────────────────────────────
    // Reentrancy guard (single slot bool)
    uint256 private _reentrancy;

    modifier nonReentrant() {
        if (_reentrancy == 1) revert ErrActive();
        _reentrancy = 1;
        _;
        _reentrancy = 0;
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // Minimal timelock (key => eta). For advanced payload TL, keep in your product if needed.
    mapping(bytes32 => uint64) public eta;

    event OpQueued(bytes32 indexed key, bytes4 op, uint64 eta);
    event OpExecuted(bytes32 indexed key, bytes4 op);
    event OpCancelled(bytes32 indexed key);

    function _queue(bytes32 key, uint64 delay) internal {
        if (delay == 0) revert ErrZero();
        if (eta[key] != 0) revert ErrExists();
        uint64 when_ = uint64(block.timestamp) + delay;
        eta[key] = when_;
        emit OpQueued(key, bytes4(key), when_);
    }
    function _exec(bytes32 key) internal {
        uint64 e = eta[key];
        if (e == 0 || block.timestamp < e) revert ErrNoOp();
        delete eta[key];
        emit OpExecuted(key, bytes4(key));
    }
    function cancelOp(bytes32 key) external onlyOwner {
        if (eta[key] == 0) revert ErrNoOp();
        delete eta[key];
        emit OpCancelled(key);
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // SafeERC20 (manual)
    function _safeTransfer(address token, address to, uint256 amount) internal {
        if (token == address(0) || to == address(0)) revert ErrZero();
        (bool ok, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, amount));
        if (!ok || (data.length != 0 && !abi.decode(data, (bool)))) revert ErrNoOp();
    }
    function _safeTransferFrom(address token, address from, address to, uint256 amount) internal {
        if (token == address(0) || from == address(0) || to == address(0)) revert ErrZero();
        (bool ok, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, amount));
        if (!ok || (data.length != 0 && !abi.decode(data, (bool)))) revert ErrNoOp();
    }
}
