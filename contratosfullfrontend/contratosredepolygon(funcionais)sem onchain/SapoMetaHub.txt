// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*
  SapoMetaHub
  - Contrato satélite ÚNICO que agrega:
    1) Achievements/Badges (ERC1155 soulbound, não-transferível)
    2) Airdrops/Recompensas com campanha Merkle (ERC20 e/ou ETH)
    3) Governança leve (timelock + enquetes sinalizadoras)
    4) Oráculos/parametrizações internas versionadas (key-value)
    5) Orquestração opcional com SuperRegistry: setTerm em batch (ROLE_TERMS)
  - Sem alterar os 6 contratos principais. Integra via interfaces seguras.
  - Segurança: owner em 2 passos, pausa global, nonReentrant,
    timelock interno para alterações críticas, erros customizados,
    SafeERC20 manual, SBT que não permite transferências.
*/

interface IERC20 {
    function transfer(address to, uint256 v) external returns (bool);
    function transferFrom(address f, address t, uint256 v) external returns (bool);
    function balanceOf(address a) external view returns (uint256);
}

interface ISuperRegistryTerms {
    // Precisa da ROLE_TERMS atribuída a este hub, senão reverte no SuperRegistry.
    function setTerm(bytes32 termId, bytes32 docHash, bool active, bool recurrent, uint32 defaultWindowSec) external;
}

contract SapoMetaHub {
    // ───────────────────────── Errors ─────────────────────────
    error ErrAuth(); error ErrPaused(); error ErrReent(); error ErrZero();
    error ErrExists(); error ErrNoOp(); error ErrAmt(); error ErrMerkle(); error ErrTime();
    error ErrCap(); error ErrBound(); error ErrSBT(); error ErrURI(); error ErrToken();

    // ───────────────────────── Core ─────────────────────────
    address public owner;
    address public pendingOwner;
    bool    public paused;
    uint256 private _reent;

    modifier onlyOwner(){ if(msg.sender!=owner) revert ErrAuth(); _; }
    modifier whenNotPaused(){ if(paused) revert ErrPaused(); _; }
    modifier nonReentrant(){ if(_reent==1) revert ErrReent(); _reent=1; _; _reent=0; }

    event OwnershipTransferStarted(address indexed from,address indexed to);
    event OwnershipTransferred(address indexed from,address indexed to);
    event Paused(address indexed by); event Unpaused(address indexed by);

    constructor(address _owner){
        if(_owner==address(0)) revert ErrZero();
        owner=_owner;
    }
    function transferOwnership(address to) external onlyOwner { if(to==address(0)) revert ErrZero(); pendingOwner=to; emit OwnershipTransferStarted(owner,to); }
    function acceptOwnership() external { if(msg.sender!=pendingOwner) revert ErrAuth(); address old=owner; owner=pendingOwner; pendingOwner=address(0); emit OwnershipTransferred(old,owner); }
    function pause() external onlyOwner { paused=true; emit Paused(msg.sender); }
    function unpause() external onlyOwner { paused=false; emit Unpaused(msg.sender); }

    // ───────────────────────── SafeERC20 ─────────────────────────
    function _safeTransfer(address token,address to,uint256 amt) internal {
        (bool ok, bytes memory r)=token.call(abi.encodeWithSelector(IERC20.transfer.selector,to,amt));
        require(ok && (r.length==0 || abi.decode(r,(bool))), "erc20");
    }
    function _safeTransferFrom(address token,address f,address t,uint256 amt) internal {
        (bool ok, bytes memory r)=token.call(abi.encodeWithSelector(IERC20.transferFrom.selector,f,t,amt));
        require(ok && (r.length==0 || abi.decode(r,(bool))), "erc20");
    }

    // ───────────────────────── Timelock interno ─────────────────────────
    uint64 public constant MIN_DELAY=24 hours; uint64 public constant MAX_DELAY=14 days;
    mapping(bytes32=>uint64) public eta; mapping(bytes32=>bytes) public payload;
    event OpQueued(bytes32 indexed key, bytes4 typ); event OpExecuted(bytes32 indexed key, bytes4 typ); event OpCancelled(bytes32 indexed key);

    function _queue(bytes32 k,uint64 d,bytes memory data) internal {
        if(eta[k]!=0) revert ErrExists();
        uint64 dd = d<MIN_DELAY?MIN_DELAY:d>MAX_DELAY?MAX_DELAY:d;
        eta[k]=uint64(block.timestamp)+dd; payload[k]=data; emit OpQueued(k,bytes4(k));
    }
    function _exec(bytes32 k) internal returns(bytes memory data){
        uint64 e=eta[k]; if(e==0||block.timestamp<e) revert ErrNoOp();
        data=payload[k]; delete eta[k]; delete payload[k]; emit OpExecuted(k,bytes4(k));
    }
    function cancelOp(bytes32 k) external onlyOwner { if(eta[k]==0) revert ErrNoOp(); delete eta[k]; delete payload[k]; emit OpCancelled(k); }

    // ───────────────────────── 1) SBT Achievements (ERC1155-like, soulbound) ─────────────────────────
    // Não-transferível: todas as transferências revert.
    mapping(uint256=>mapping(address=>uint256)) private _bal1155;
    mapping(address=>mapping(address=>bool))   private _op;
    string private _baseURI; bool public metadataFrozen;
    mapping(uint256=>bool) public badgeFrozen; // opcional para congelar metadado por ID

    event ApprovalForAll(address indexed owner,address indexed operator,bool approved);
    event TransferSingle(address indexed op,address indexed from,address indexed to,uint256 id,uint256 value);
    event URI(string value,uint256 indexed id);

    function setApprovalForAll(address op_,bool ok) external whenNotPaused { _op[msg.sender][op_]=ok; emit ApprovalForAll(msg.sender,op_,ok); }
    function isApprovedForAll(address a,address op_) external view returns(bool){ return _op[a][op_]; }
    function balanceOf(address a,uint256 id) external view returns(uint256){ return _bal1155[id][a]; }
    function uri(uint256 id) external view returns(string memory){ return string(abi.encodePacked(_baseURI,_utoa(id))); }
    function setBaseURI(string calldata u) external onlyOwner { if(metadataFrozen) revert ErrURI(); _baseURI=u; }
    function freezeAllMetadata() external onlyOwner { metadataFrozen=true; }
    function freezeBadge(uint256 id) external onlyOwner { badgeFrozen[id]=true; }

    // Soulbound: operações de transferência desativadas
    function safeTransferFrom(address,address,uint256,uint256,bytes calldata) external pure { revert ErrSBT(); }
    function safeBatchTransferFrom(address,address,uint256[] calldata,uint256[] calldata,bytes calldata) external pure { revert ErrSBT(); }

    // Mint/BatchMint/Revogar
    event BadgeMinted(address indexed to,uint256 indexed id,uint256 amt);
    event BadgeRevoked(address indexed from,uint256 indexed id,uint256 amt);

    function mintBadge(address to,uint256 id,uint256 amt) external onlyOwner whenNotPaused {
        if(to==address(0)||amt==0) revert ErrZero();
        _bal1155[id][to]+=amt; emit TransferSingle(msg.sender,address(0),to,id,amt); emit BadgeMinted(to,id,amt);
    }
    function mintBadgeBatch(address[] calldata to,uint256 id,uint256 amtEach) external onlyOwner whenNotPaused {
        if(id==0||amtEach==0) revert ErrZero();
        for(uint256 i;i<to.length;i++){ address a=to[i]; if(a==address(0)) revert ErrZero(); _bal1155[id][a]+=amtEach; emit TransferSingle(msg.sender,address(0),a,id,amtEach); emit BadgeMinted(a,id,amtEach); }
    }
    function revokeBadge(address from,uint256 id,uint256 amt) external onlyOwner whenNotPaused {
        uint256 b=_bal1155[id][from]; if(b<amt) revert ErrAmt();
        unchecked{ _bal1155[id][from]=b-amt; } emit TransferSingle(msg.sender,from,address(0),id,amt); emit BadgeRevoked(from,id,amt);
    }

    // ───────────────────────── 2) Airdrops/Recompensas (Merkle) ─────────────────────────
    struct Campaign {
        address token;      // address(0)=ETH, !=0 ERC20
        bytes32 merkleRoot; // leaf = keccak256(abi.encode(index,account,amount))
        uint64  deadline;   // timestamp limite
        bool    active;
        uint256 funded;     // saldo alocado (para controle)
        uint256 claimedTotal;
    }
    mapping(uint256=>Campaign) public campaigns;
    mapping(uint256=>mapping(uint256=>uint256)) private claimedBitmap; // campaignId -> word -> bitmap

    event CampaignCreated(uint256 indexed id,address token,bytes32 root,uint64 deadline,uint256 funded);
    event CampaignFunded(uint256 indexed id,uint256 amount);
    event CampaignClosed(uint256 indexed id);
    event Claimed(uint256 indexed id,uint256 indexed index,address indexed account,uint256 amount);

    function _isClaimed(uint256 id,uint256 index) internal view returns(bool){
        uint256 word = index>>8; uint256 bit = 1 << (index & 255);
        return (claimedBitmap[id][word] & bit) != 0;
    }
    function _setClaimed(uint256 id,uint256 index) internal {
        uint256 word = index>>8; uint256 bit = 1 << (index & 255);
        claimedBitmap[id][word] |= bit;
    }
    function _verify(bytes32 root, bytes32 leaf, bytes32[] calldata proof) internal pure returns(bool ok){
        bytes32 computed=leaf;
        for(uint256 i;i<proof.length;i++){
            bytes32 p=proof[i];
            computed = computed < p ? keccak256(abi.encodePacked(computed,p)) : keccak256(abi.encodePacked(p,computed));
        }
        return computed==root;
    }

    function createCampaign(
        uint256 id,
        address token,
        bytes32 merkleRoot,
        uint64  deadline
    ) external onlyOwner whenNotPaused payable {
        if(campaigns[id].active) revert ErrExists();
        if(merkleRoot==bytes32(0) || deadline<=block.timestamp) revert ErrTime();
        campaigns[id]=Campaign(token,merkleRoot,deadline,true,0,0);

        uint256 fund = msg.value;
        if(token!=address(0) && fund>0) revert ErrToken(); // ETH só se token==0
        emit CampaignCreated(id,token,merkleRoot,deadline,fund);

        if(token==address(0) && fund>0){
            campaigns[id].funded += fund; emit CampaignFunded(id,fund);
        }
    }
    function fundCampaign(uint256 id,uint256 amount) external onlyOwner whenNotPaused payable {
        Campaign storage C=campaigns[id]; if(!C.active) revert ErrNoOp();
        if(C.token==address(0)){
            if(msg.value==0) revert ErrAmt(); C.funded += msg.value; emit CampaignFunded(id,msg.value);
        } else {
            if(amount==0) revert ErrAmt(); _safeTransferFrom(C.token,msg.sender,address(this),amount); C.funded += amount; emit CampaignFunded(id,amount);
        }
    }
    function closeCampaign(uint256 id) external onlyOwner { Campaign storage C=campaigns[id]; if(!C.active) revert ErrNoOp(); C.active=false; emit CampaignClosed(id); }

    function claim(
        uint256 id,
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata proof
    ) external whenNotPaused nonReentrant {
        Campaign storage C=campaigns[id];
        if(!C.active || block.timestamp>C.deadline) revert ErrTime();
        if(_isClaimed(id,index)) revert ErrExists();
        bytes32 leaf=keccak256(abi.encode(index,account,amount));
        if(!_verify(C.merkleRoot,leaf,proof)) revert ErrMerkle();

        _setClaimed(id,index);
        C.claimedTotal += amount;

        if(C.token==address(0)){
            if(C.funded<amount) revert ErrAmt(); C.funded-=amount;
            (bool ok,)=payable(account).call{value:amount}(""); require(ok,"eth");
        } else {
            if(C.funded<amount) revert ErrAmt(); C.funded-=amount;
            _safeTransfer(C.token,account,amount);
        }
        emit Claimed(id,index,account,amount);
    }

    // ───────────────────────── 3) Governança leve ─────────────────────────
    // Timelock já protege alterações internas. Enquetes públicas servem como "sinalização".
    enum PollStatus{ NONE, OPEN, CLOSED }
    struct Poll {
        bytes32 topic;      // ex: keccak256("XP_BONUS_SEASON_1")
        uint64  start;
        uint64  end;
        uint256 yes;
        uint256 no;
        PollStatus status;
        mapping(address=>bool) voted;
    }
    mapping(uint256=>Poll) private polls;
    event PollOpened(uint256 indexed id, bytes32 topic, uint64 start, uint64 end);
    event Voted(uint256 indexed id, address indexed voter, bool support);
    event PollClosed(uint256 indexed id, uint256 yes, uint256 no);

    function openPoll(uint256 id, bytes32 topic, uint64 duration) external onlyOwner whenNotPaused {
        Poll storage P=polls[id]; if(P.status!=PollStatus.NONE) revert ErrExists();
        if(topic==bytes32(0) || duration<5 minutes || duration>14 days) revert ErrBound();
        P.topic=topic; P.start=uint64(block.timestamp); P.end=P.start+duration; P.status=PollStatus.OPEN;
        emit PollOpened(id,topic,P.start,P.end);
    }
    function vote(uint256 id, bool support) external whenNotPaused {
        Poll storage P=polls[id]; if(P.status!=PollStatus.OPEN || block.timestamp>P.end) revert ErrTime();
        if(P.voted[msg.sender]) revert ErrExists(); P.voted[msg.sender]=true;
        if(support) P.yes+=1; else P.no+=1; emit Voted(id,msg.sender,support);
    }
    function closePoll(uint256 id) external onlyOwner {
        Poll storage P=polls[id]; if(P.status!=PollStatus.OPEN) revert ErrNoOp();
        P.status=PollStatus.CLOSED; emit PollClosed(id,P.yes,P.no);
    }
    function pollResult(uint256 id) external view returns(bytes32 topic,uint64 start,uint64 end,uint8 status,uint256 yes,uint256 no){
        Poll storage P=polls[id]; return (P.topic,P.start,P.end,uint8(P.status),P.yes,P.no);
    }

    // ───────────────────────── 4) Oráculos internos / parâmetros ─────────────────────────
    // KVs versionados com timelock para updates (e.g., bônus sazonais, limites).
    struct KV { uint256 val; uint64 updatedAt; uint32 ver; }
    mapping(bytes32=>KV) public config;
    event KVQueued(bytes32 indexed key, uint256 newVal, uint64 eta);
    event KVSet(bytes32 indexed key, uint256 val, uint32 ver, uint64 at);

    function queueSetKV(bytes32 key,uint256 newVal,uint64 delay) external onlyOwner returns(bytes32 k){
        if(key==bytes32(0)) revert ErrZero(); k=keccak256(abi.encode("kv",key,newVal,address(this)));
        _queue(k,delay,abi.encode(key,newVal)); emit KVQueued(key,newVal,eta[k]);
    }
    function execSetKV(bytes32 k) external onlyOwner {
        (bytes32 key,uint256 v)=abi.decode(_exec(k),(bytes32,uint256));
        KV storage K=config[key]; K.val=v; K.updatedAt=uint64(block.timestamp); unchecked{ K.ver+=1; }
        emit KVSet(key,v,K.ver,K.updatedAt);
    }

    // ───────────────────────── 5) Orquestração com SuperRegistry (Termos) ─────────────────────────
    // Observação: este hub precisa ter ROLE_TERMS no SuperRegistry para setTerm.
    address public superRegistry;
    event RegistrySet(address reg);

    function setSuperRegistry(address reg) external onlyOwner { superRegistry=reg; emit RegistrySet(reg); }

    function setTermsBatch(
        bytes32[] calldata termIds,
        bytes32[] calldata docHashes,
        bool[]    calldata actives,
        bool[]    calldata recurrents,
        uint32[]  calldata defaultWindows
    ) external onlyOwner whenNotPaused {
        if(superRegistry==address(0)) revert ErrZero();
        uint256 n=termIds.length;
        if(n==0 || n!=docHashes.length || n!=actives.length || n!=recurrents.length || n!=defaultWindows.length) revert ErrBound();
        for(uint256 i;i<n;i++){
            (bool ok,)=superRegistry.call(
                abi.encodeWithSelector(
                    ISuperRegistryTerms.setTerm.selector,
                    termIds[i], docHashes[i], actives[i], recurrents[i], defaultWindows[i]
                )
            );
            require(ok,"setTerm");
        }
    }

    // ───────────────────────── Util ─────────────────────────
    function _utoa(uint256 v) internal pure returns(string memory){
        if(v==0) return "0";
        uint256 j=v; uint256 len; while(j!=0){ len++; j/=10; }
        bytes memory b=new bytes(len);
        while(v!=0){ len--; b[len]=bytes1(uint8(48+v%10)); v/=10; }
        return string(b);
    }

    receive() external payable {}
}
