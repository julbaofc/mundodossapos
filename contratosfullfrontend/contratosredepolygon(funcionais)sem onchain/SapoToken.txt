// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*
  SapoToken
  - ERC20 minimal, decimals = 0
  - Cap finalizável, owner em 2 passos, pausa
  - Swap hook para SapoFinance
  - Otimizações: uint32 para balances, allowances; erros customizados
*/

contract SapoToken {
    error ErrAuth();
    error ErrPaused();
    error ErrZero();
    error ErrCap();
    error ErrBal();
    error ErrAllow();
    error ErrSet();
    error ErrFinal();

    string public constant name     = "SapoToken";
    string public constant symbol   = "SAPO";
    uint8  public constant decimals = 0;

    address public owner;
    address public pendingOwner;
    bool    public paused;

    modifier onlyOwner() {
        if (msg.sender != owner) revert ErrAuth();
        _;
    }
    modifier whenNotPaused() {
        if (paused) revert ErrPaused();
        _;
    }

    event OwnershipTransferStarted(address from, address to);
    event OwnershipTransferred(address from, address to);
    event Paused(address by);
    event Unpaused(address by);

    uint32 private _totalSupply;
    uint32 private _cap;
    bool   public  capFinalized;

    mapping(address => uint32)                   private _bal;
    mapping(address => mapping(address => uint32)) private _allow;

    address public swapContract;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event CapChanged(uint32 oldCap, uint32 newCap);
    event CapFinalized(uint32 cap);
    event SwapSet(address swap);

    constructor(address _owner, uint32 cap_) {
        if (_owner == address(0)) revert ErrZero();
        owner = _owner;
        _cap   = cap_;
    }

    function transferOwnership(address to) external onlyOwner {
        if (to == address(0)) revert ErrZero();
        pendingOwner = to;
        emit OwnershipTransferStarted(owner, to);
    }
    function acceptOwnership() external {
        if (msg.sender != pendingOwner) revert ErrAuth();
        address old = owner;
        owner        = pendingOwner;
        pendingOwner = address(0);
        emit OwnershipTransferred(old, owner);
    }

    function pause()   external onlyOwner { paused = true;  emit Paused(msg.sender); }
    function unpause() external onlyOwner { paused = false; emit Unpaused(msg.sender); }

    function totalSupply() external view returns (uint256) { return _totalSupply; }
    function cap()         external view returns (uint256) { return _cap;       }
    function balanceOf(address a) external view returns (uint256) { return _bal[a]; }
    function allowance(address o, address s) external view returns (uint256) { return _allow[o][s]; }

    function transfer(address to, uint256 amt) external whenNotPaused returns (bool) {
        _transfer(msg.sender, to, uint32(amt));
        return true;
    }
    function approve(address spender, uint256 amt) external whenNotPaused returns (bool) {
        _allow[msg.sender][spender] = uint32(amt);
        emit Approval(msg.sender, spender, amt);
        return true;
    }
    function transferFrom(address from, address to, uint256 amt) external whenNotPaused returns (bool) {
        uint32 allowed = _allow[from][msg.sender];
        uint32 value   = uint32(amt);
        if (allowed < value) revert ErrAllow();
        if (allowed != type(uint32).max) {
            unchecked { _allow[from][msg.sender] = allowed - value; }
        }
        _transfer(from, to, value);
        return true;
    }

    function _transfer(address from, address to, uint32 value) internal {
        if (to == address(0)) revert ErrZero();
        uint32 balFrom = _bal[from];
        if (balFrom < value) revert ErrBal();
        unchecked {
            _bal[from] = balFrom - value;
            _bal[to]   += value;
        }
        emit Transfer(from, to, value);
    }

    function mint(address to, uint256 amt) external onlyOwner whenNotPaused {
        if (to == address(0)) revert ErrZero();
        uint32 value = uint32(amt);
        uint32 newSupply;
        unchecked { newSupply = _totalSupply + value; }
        if (newSupply > _cap) revert ErrCap();
        _totalSupply = newSupply;
        unchecked { _bal[to] += value; }
        emit Transfer(address(0), to, value);
    }

    function burn(uint256 amt) external whenNotPaused {
        uint32 value = uint32(amt);
        uint32 bal   = _bal[msg.sender];
        if (bal < value) revert ErrBal();
        unchecked {
            _bal[msg.sender] = bal - value;
            _totalSupply    -= value;
        }
        emit Transfer(msg.sender, address(0), value);
    }

    function setCap(uint256 newCap) external onlyOwner {
        if (capFinalized) revert ErrFinal();
        uint32 nc = uint32(newCap);
        if (nc < _totalSupply) revert ErrCap();
        uint32 old = _cap;
        _cap = nc;
        emit CapChanged(old, nc);
    }

    function finalizeCap() external onlyOwner {
        capFinalized = true;
        emit CapFinalized(_cap);
    }

    function setSwapContract(address s) external onlyOwner {
        if (s == address(0) || swapContract != address(0)) revert ErrSet();
        swapContract = s;
        emit SwapSet(s);
    }

    function swapTransfer(address from, address to, uint256 amt) external whenNotPaused {
        if (msg.sender != swapContract) revert ErrAuth();
        _transfer(from, to, uint32(amt));
    }

    // Optional helpers
    function increaseAllowance(address spender, uint256 added) external whenNotPaused returns (bool) {
        uint32 old = _allow[msg.sender][spender];
        uint32 inc = uint32(added);
        unchecked { _allow[msg.sender][spender] = old + inc; }
        emit Approval(msg.sender, spender, old + inc);
        return true;
    }
    function decreaseAllowance(address spender, uint256 subtracted) external whenNotPaused returns (bool) {
        uint32 old = _allow[msg.sender][spender];
        uint32 dec = uint32(subtracted);
        if (old < dec) revert ErrAllow();
        unchecked { _allow[msg.sender][spender] = old - dec; }
        emit Approval(msg.sender, spender, old - dec);
        return true;
    }
}
